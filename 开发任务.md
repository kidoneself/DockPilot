# DockPilot 功能优化与开发任务清单

## 🧩 功能概览

本文档整理了 DockPilot 开发计划，涵盖用户体验、功能增强、图标管理、网络配置等方面，供参考。

---

## ✅ 已知问题
- [x] 停止容器后端口不显示（建议保留端口信息展示，便于排查）

---

## 🔐 用户管理
- [x] 前端页面增加登录用户名与密码（默认配置、登录态维持）
- [x] 后台支持修改用户名和密码（前端界面、后端接口、加密存储）

---

## 🧭 导航体验优化
- [x] 左侧菜单增加"返回导航中心"
- [x] 点击 DockPilot 图标跳转首页
- [x] 图标名称统一为 DockPilot

---

## ⚡ 容器导入与快捷导航
- [ ] 支持宿主机容器批量导入到导航页（自动扫描、判断端口、添加到导航）
- [ ] 允许设置内网基础 IP，自动拼接链接

---

## 🎨 图标管理
- [ ] 导航条目支持自定义图标链接（上传/外链/base64）
- [ ] 内置图标库 / 图标自动采集（label、image名推测、图库浏览）
- [ ] 避免图标重复冲突（hash命名、防缓存覆盖）

---

## 🌐 网络代理支持
- [ ] 明确区分加速地址与代理地址
- [ ] 支持 SOCKS5 / HTTP / HTTPS 代理配置（网络设置界面、测试按钮）
- [ ] 避免与宿主已配置的加速地址冲突

## 🔄 容器网络配置管理
- [ ] 支持容器更新时的网络配置验证（网络模式、端口映射、DNS配置等）
- [ ] 支持自定义网络模式（bridge、host、none、container等）
- [ ] 支持网络参数配置（DNS、主机名、网络别名等）
- [ ] 支持网络限制配置（带宽、连接数等）
- [ ] 支持网络安全配置（访问控制、防火墙规则等）
- [ ] 支持网络配置的备份和恢复

---

## 🧩 容器部署扩展
- [ ] 支持 Compose 文件部署新容器（上传yml、服务列表、参数覆盖）

---

## 📦 本地镜像仓库支持
- [ ] 内建或对接私有镜像仓库（本地缓存、详情、标签管理）
- [ ] 支持收藏镜像自动更新（定时检测、自动拉取、通知）
- [ ] 支持多机同步 / 推送机制（长期规划）

---

## 🆕 多服务端统一管理与切换 · 待办任务
- [ ] 前端支持自由切换 HTTP 请求和 WebSocket 连接的目标服务端，实现一个前端管理多个后端实例。
- [ ] 前端支持动态添加、编辑、删除服务端信息，切换后所有请求都走选中的服务端。
- [ ] 服务端实现服务端信息的增删查改接口，并支持服务端列表的同步接口（推送/拉取均可）。
- [ ] 服务端A添加服务端B时，A数据库增加B信息，并通过接口同步服务端列表到B，B收到后更新本地数据库，实现所有服务端信息一致。
- [ ] 切换服务端后，所有请求（HTTP/WS）都走当前选中的服务端，实现"谁都可以管谁"。
- [ ] 服务端信息同步需防止同步风暴、数据冲突、循环同步等问题，同步接口需加鉴权，服务端信息需带唯一ID和版本号。
- [ ] 切换服务端时需检测连通性，不可用时提示用户，必要时刷新登录态。
- [ ] 新增服务端时，前端应先请求目标服务端的版本信息接口，只有版本一致或兼容时才允许添加，避免后续同步和管理出现兼容性问题。

---

## 📂 数据库与配置持久化
- [ ] 将数据库文件和所有重要配置统一放到 config 文件夹，并在 Docker 部署时通过挂载 config 目录实现数据和配置持久化。

---

## 💾 数据备份与恢复
- [ ] 支持导出容器镜像（选择镜像、导出为tar文件、进度显示）
- [ ] 支持备份配置文件夹（选择目录、压缩打包、自动命名）
- [ ] 支持定时自动备份（可配置备份周期、保留份数）
- [ ] 支持备份文件管理（查看、下载、删除）
- [ ] 支持从备份恢复（选择备份文件、验证完整性、恢复确认）

---

## 🔄 WebSocket消息处理优化
### 目的
1. 提升用户体验
   - 实时显示操作进度
   - 及时反馈操作状态
   - 统一错误提示格式
2. 提高代码质量
   - 统一消息处理流程
   - 减少重复代码
   - 便于维护和扩展
3. 增强系统稳定性
   - 统一错误处理
   - 完善异常恢复
   - 提高并发处理能力

### 具体方案
1. 统一消息模型
   ```java
   public class WebSocketMessage {
       private String type;        // 消息类型
       private String taskId;      // 任务ID
       private Object data;        // 消息数据
       private String message;     // 消息内容
       private Integer progress;   // 进度(可选)
       private String status;      // 状态(STARTED/PROGRESS/COMPLETED/ERROR)
   }
   ```

2. 改进消息发送器
   ```java
   public class WebSocketMessageSender {
       // 发送普通消息
       public void sendMessage(WebSocketSession session, MessageType type, String taskId, Object data)
       
       // 发送进度消息
       public void sendProgress(WebSocketSession session, String taskId, int progress, String message)
       
       // 发送错误消息
       public void sendError(WebSocketSession session, String taskId, String errorMessage)
   }
   ```

3. 改进基础消息处理器
   ```java
   public abstract class BaseMessageHandler {
       // 统一的消息处理流程
       protected void handleMessage(WebSocketSession session, WebSocketMessage message) {
           try {
               // 1. 发送开始消息
               sendStartMessage(session, message);
               
               // 2. 执行具体操作
               Object result = doHandle(message);
               
               // 3. 发送完成消息
               sendCompleteMessage(session, message, result);
           } catch (Exception e) {
               // 4. 发送错误消息
               sendErrorMessage(session, message, e);
           }
       }
       
       // 具体操作由子类实现
       protected abstract Object doHandle(WebSocketMessage message);
   }
   ```

4. 改造服务层
   ```java
   public interface AsyncOperation<T, R> {
       // 执行异步操作
       Flux<R> execute(T request);
       
       // 获取操作类型
       String getOperationType();
   }
   
   @Service
   public class ImageService {
       public Flux<ImageUpdateResult> updateImage(String image, String tag) {
           return Flux.create(sink -> {
               // 异步执行镜像更新
               dockerService.pullImage(image, tag, new PullImageCallback() {
                   @Override
                   public void onProgress(int progress, String status) {
                       sink.next(new ProgressResult(progress, status));
                   }
                   
                   @Override
                   public void onComplete() {
                       sink.next(new ImageUpdateResult(true));
                       sink.complete();
                   }
                   
                   @Override
                   public void onError(String error) {
                       sink.error(new RuntimeException(error));
                   }
               });
           });
       }
   }
   ```

5. 前端适配
   ```typescript
   class WebSocketClient {
       // 发送消息并等待结果
       async sendMessage(type: string, data: any): Promise<any> {
           return new Promise((resolve, reject) => {
               const taskId = generateTaskId();
               
               // 注册消息处理器
               this.messageHandlers.set(taskId, (response) => {
                   if (response.status === 'ERROR') {
                       reject(new Error(response.message));
                   } else if (response.status === 'COMPLETED') {
                       resolve(response.data);
                   } else if (response.status === 'PROGRESS') {
                       // 处理进度更新
                       this.handleProgress(response);
                   }
               });
               
               // 发送消息
               this.ws.send(JSON.stringify({
                   type,
                   taskId,
                   data,
                   status: 'STARTED'
               }));
           });
       }
   }
   ```

### 实施步骤
1. 统一消息模型（添加进度和状态字段、统一消息格式）
2. 改进消息发送器（添加进度发送方法、统一错误处理）
3. 改进基础消息处理器（支持进度处理、统一处理流程）
4. 改造服务层（添加异步支持、统一返回格式）
5. 适配前端（统一消息处理、添加进度显示）

### 注意事项
1. 保持向后兼容
   - 新消息格式需要兼容旧版本
   - 渐进式替换现有实现
2. 性能考虑
   - 避免频繁的消息发送
   - 合理控制消息大小
3. 错误处理
   - 统一的错误码
   - 友好的错误提示
4. 测试覆盖
   - 单元测试
   - 集成测试
   - 性能测试

---



